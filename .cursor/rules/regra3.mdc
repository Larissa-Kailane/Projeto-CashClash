---
description: 
globs: 
alwaysApply: true
---
Regra 3: Regras de Negócio Centralizadas, Coesas e Orientadas à Arquitetura Django

Todas as regras de negócio – como controle de vidas, verificação de respostas, progressão no tabuleiro, reinício da partida e concessão de recompensas – devem estar centralizadas nos módulos Model e Controller do Django, utilizando os recursos nativos do framework para garantir consistência, segurança e reutilização de lógica.

A modelagem de dados deve ser feita com models.Model do Django, usando PostgreSQL como backend relacional. Toda a manipulação de estado do jogo (posição do jogador, vidas restantes, perguntas associadas à casa, etc.) deve ser encapsulada em métodos de instância ou de classe dentro desses modelos.

A lógica de controle (fluxo entre telas, controle de rotas e resposta a eventos) deve ser definida de forma clara nas Views (views.py) ou Controllers customizados, nunca diluída diretamente nas templates (HTML) ou scripts JavaScript. A responsabilidade por calcular, decidir ou validar nunca deve estar no front-end – apenas no back-end.

As migrations do Django devem refletir com precisão a estrutura de dados real e devem ser geradas e aplicadas com cautela, garantindo versionamento e consistência. Para interações assíncronas ou atualizações dinâmicas no front-end, bibliotecas JS leves podem ser utilizadas (ex: Alpine.js ou jQuery), mas sempre consumindo endpoints REST bem definidos no back-end (via Django Views ou Django REST Framework, se necessário).

Todo comportamento do jogo deve ser:
	•	Documentado em docstrings nas classes e métodos principais.
	•	Coberto por testes unitários (usando unittest, pytest ou Django TestCase).
	•	Isolado de código visual (HTML/CSS) para garantir modularidade e testabilidade.

Essa separação clara garante manutenibilidade, escalabilidade e clareza da arquitetura do sistema – reduzindo bugs, duplicações e inconsistências futuras.